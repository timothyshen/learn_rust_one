# 闭包和迭代器

## 闭包

闭包是一种匿名函数，赋值给变量也可以作为参数传递给其他函数。不同于普通函数，闭包可以捕获其所在函数的局部变量，即使这些变量在函数返回后依然存在。

```rust
fn main() {
    let x = 1;
    let add = |y| x + y;
    println!("{}", add(2)); // 3
}
```

这里的`add`是一个闭包，它捕获了`x`的值。

用闭包简化代码

```rust
use std::thread;
use std::time::Duration;

// 开始健身，好累，我得发出声音：muuuu...
fn muuuuu(intensity: u32) -> u32 {
    println!("muuuu.....");
    thread::sleep(Duration::from_secs(2));
    intensity
}

fn workout(intensity: u32, random_number: u32) {
    if intensity < 25 {
        println!(
            "今天活力满满，先做 {} 个俯卧撑!",
            muuuuu(intensity)
        );
        println!(
            "旁边有妹子在看，俯卧撑太low，再来 {} 组卧推!",
            muuuuu(intensity)
        );
    } else if random_number == 3 {
        println!("昨天练过度了，今天还是休息下吧！");
    } else {
        println!(
            "昨天练过度了，今天干干有氧，跑步 {} 分钟!",
            muuuuu(intensity)
        );
    }
}

fn main() {
    // 强度
    let intensity = 10;
    // 随机值用来决定某个选择
    let random_number = 7;

    // 开始健身
    workout(intensity, random_number);
}
```

这里我们用闭包修改一下代码， 假设我们之后不在需要`muuuuu`函数，我们可以将其替换为闭包。

```rust
fn muuuuu(intensity: u32) -> u32 {
    println!("muuuu.....");
    thread::sleep(Duration::from_secs(2));
    intensity
}

fn workout(intensity: u32, random_number: u32) {
    let action = muuuuu;
    if intensity < 25 {
        println!(
            "今天活力满满，先做 {} 个俯卧撑!",
            action(intensity)
        );
        println!(
            "旁边有妹子在看，俯卧撑太low，再来 {} 组卧推!",
            action(intensity)
        );
    } else if random_number == 3 {
        println!("昨天练过度了，今天还是休息下吧！");
    } else {
        println!(
            "昨天练过度了，今天干干有氧，跑步 {} 分钟!",
            action(intensity)
        );
    }
}
```

那这时候我们发现intensity改变怎么办？

```rust
fn workout(intensity: u32, random_number: u32) {
    let action = || {
        println!("muuuu.....");
        thread::sleep(Duration::from_secs(2));
        intensity
    };

    if intensity < 25 {
        println!(
            "今天活力满满，先做 {} 个俯卧撑!",
            action()
        );
        println!(
            "旁边有妹子在看，俯卧撑太low，再来 {} 组卧推!",
            action()
        );
    } else if random_number == 3 {
        println!("昨天练过度了，今天还是休息下吧！");
    } else {
        println!(
            "昨天练过度了，今天干干有氧，跑步 {} 分钟!",
            action()
        );
    }
}
```

这里我们将`muuuuu`函数替换为一个闭包，这个闭包不接受参数，但是可以访问`intensity`的值。也就是说未来我们可以随时改变`intensity`的值，而不用修改`workout`函数。

Rust的闭包借鉴了ruby和smalltalk，语法如下：

```
|param1, param2| {
    expression 1;
    expression 2;
    return expression 3;
}

or 

|param1, param2| expression
```

闭包类型主要有三：
- 省略参数
- 返回类型
- 花括号

类型推导虽然好用，但是一旦被编译，类型就固定了。

结构体中的闭包
- 一个闭包用于获取值
- 一个变量用于存

```rust
struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    query: T,
    value: Option<u32>,
}
```

T是一个闭包，接受一个u32参数，返回一个u32值。
Fn是一个trait，表示这是一个闭包。

捕获作用域中的值

这个的意思是，闭包可以捕获作用域中的值，这个值可以在闭包中使用，但是不能改变。

```rust

fn main() {
    let x = 4;
    let equal_to_x = |z| z == x;
    let y = 4;
    assert!(equal_to_x(y));
}
```

这里的`equal_to_x`闭包捕获了`x`的值，所以`equal_to_x`闭包可以使用`x`的值。

闭包 -> 额外内存

三种Fn trait

转移所有权、可变借用、不可变借用

- FnOnce，该类型的闭包会拿走被捕获变量的所有权。Once 顾名思义，说明该闭包只能运行一次：
- FnMut，该类型的闭包可以改变被捕获变量的值。
- Fn，该类型的闭包只能读取被捕获变量的值。