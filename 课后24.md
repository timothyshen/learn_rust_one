# 错误哲学和返回值

## 1. 错误哲学

在 Rust 中，错误处理是一个非常重要的概念。Rust 的错误处理哲学是：

- 可恢复错误：通常用于从系统全局角度来看可以接受的错误，比如文件不存在、网络连接中断等。
- 不可恢复错误：通常用于程序内部错误，比如数组越界、空指针等。

Rust 也有自己的方式：`Result<T, E>` 和 `panic!` 宏。

## panic 深入剖析

`panic!` 宏是 Rust 的错误处理机制之一，它会导致程序崩溃并输出错误信息。`panic!` 有两种模式：

- 被动触发：当程序遇到不可恢复错误时，会自动触发 panic。
- 主动触发：当程序遇到不可恢复错误时，可以使用 `panic!` 主动触发 panic。

切记，一定是不可恢复的错误，才调用 panic! 处理，你总不想系统仅仅因为用户随便传入一个非法参数就崩溃吧？所以，只有当你不知道该如何处理时，再去调用 panic!.

```
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

这里包含了两个信息：

- main 函数所在的线程崩溃了。
- 再加上一个环境变量，可以显示详细的调用栈信息。

## panic 时的终止方法

当 panic 发生时会有两种方式终止程序：

- 栈展开
- 直接终止

默认情况下，Rust 会选择栈展开，这样可以保证程序在 panic 时，可以释放资源。但是，如果你想要快速终止程序，可以使用 `panic=abort` 参数。

## 何时该使用 panic!

### 示例、原型、测试

这几个场景下，需要快速地搭建代码，错误处理会拖慢编码的速度，也不是特别有必要，因此通过 unwrap、expect 等方法来处理是最快的。

同时，当我们回头准备做错误处理时，可以全局搜索这些方法，不遗漏地进行替换。

### 你确切的知道你的程序是正确时，可以使用 panic

因为 panic 的触发方式比错误处理要简单，因此可以让代码更清晰，可读性也更加好，当我们的代码注定是正确时，你可以用 unwrap 等方法直接进行处理，反正也不可能 panic

### 可能导致全局有害状态的时候

有害状态：

- 非预期的错误
- 后续的代码无法继续执行
- 内存安全问题
