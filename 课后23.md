# 认识生命周期

`TODO review`

生命周期 = 引用的有效作用域

- 编译器大部分大部分时候可以自动推导类型，编译器大多数时间也可以自动推导生命周期。
- 在多种类型存在时，编译器会报错，需要手动指定生命周期。

悬垂指针和生命周期

- 悬垂指针：指针指向的内存已经被释放。
- Rust 编译器会在编译时检查悬垂指针。
- 生命周期的引入，可以让编译器在编译时检查悬垂指针。

```rust
fn main() {
    let r;
    {
        let x = 5;
        r = &x;
    }
    println!("r: {}", r);
}
```

上面的代码会报错，因为 `x` 的生命周期已经结束，`r` 指向的内存已经被释放。

借用检查

- 为了确保 Rust 的所有权和借用的正确性，借用检查器（borrow checker）
- 借用检查器会在编译时检查引用的有效性。
- 编译通过，很简单，只要‘b 比 ’a 大就好。

## 函数中的生命周期

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

上面的代码会报错，因为编译器需要知道这些，来确保函数调用后的引用生命周期分析。

所以我们需要手动指定生命周期。

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

这两个参数 first 和 second 至少活得和'a 一样久，至于到底活多久或者哪个活得更久，抱歉我们都无法得知

- 和泛型一样，使用生命周期参数，需要先声明 <'a>
- x、y 和返回值至少活得和 'a 一样久(因为返回值要么是 x，要么是 y)

深入思考生命周期标注

- 生命周期标注是用来指定引用的生命周期的。
- 生命周期标注和泛型参数类似，都是在函数签名中声明的。

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

生命周期语法用来将函数的多个引用参数和返回值的作用域关联到一起，一旦关联到一起后，Rust 就拥有充分的信息来确保我们的操作是内存安全的。

## 结构体中的生命周期

在结构体中使用引用也变得可能：只要为结构体中的每一个引用标注上生命周期

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

- 结构体中的引用必须要有生命周期标注。
- 结构体中的生命周期标注和函数中的生命周期标注类似，都是在结构体的定义中声明的。

生命周期消除

编译器为了简化用户的使用，运用了生命周期消除大法。

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

对于 first_word 函数，它的返回值是一个引用类型，那么该引用只有两种情况：

- 从参数获取
- 从函数体内部新创建的变量获取

在开始之前有几点需要注意：

- 消除规则不是万能的，若编译器不能确定某件事是正确时，会直接判为不正确，那么你还是需要手动标注生命周期
- 函数或者方法中，参数的生命周期被称为 输入生命周期，返回值的生命周期被称为 输出生命周期

### 三条消除规则

1. 每一个引用参数都会获得独自的生命周期
2. 若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期
3. 若存在多个输入生命周期，且其中一个是 &self 或 &mut self，则 &self 的生命周期被赋给所有的输出生命周期

方法中的生命周期

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

- impl 中必须使用结构体的完整名称，包括 <'a>，因为生命周期标注也是结构体类型的一部分！
- 方法签名中，往往不需要标注生命周期，得益于生命周期消除的第一和第三规则

## 静态生命周期

你的所有引用的生命周期都是正确的，只是编译器太笨不懂罢了

总结下：

- 生命周期 'static 意味着能和程序活得一样久，例如字符串字面量和特征对象
- 实在遇到解决不了的生命周期标注问题，可以尝试 T: 'static，有时候它会给你奇迹
